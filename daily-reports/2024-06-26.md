

```json
class DeleteDuplicates {
	solve(head) {
	// Your code here
	pred = sentinel;
		go for each and if its the same then skip. if the same skip.
		const sentine = New ListNode(0)
		sentine.next = head;

		while head{
			if head.next != Null & head.val == head.next.val:
			 while ...tathst he case . move head.
			else:
				pred = pred.next
		}
		head = head.next
		

		return sentinel.next
	}
}


module.exports = { Problem: DeleteDuplicates };

```



```
class RemoveNthFromEnd {	// Your code here

# Reverse a

Fast slow? To find the middle?

for let i... n + 1
	first = first.next
while first:
	first = second
	first - second

secon.

And from th emiddle?
}


function ListNode(val) {
    this.val = val;
    this.next = null;
  }


module.exports = { Problem: RemoveNthFromEnd };
```


```js
class Solution {	// Your code here
		
	}
}


module.exports = { Problem: Solution };
```



```
class Solution {	// Your code here
	solve(head, m, n){
	
		if(!head){
			return null
		}
	let cur = head;
	let prev = null;
	while(m > 1){
		prev = cur 
	cur = ucr.next
	m --
	n--
	}
	}
}


module.exports = { Problem: Solution };
```
```
```


```
class MinMutation {
    solve(start, end, bank) {
      // TODO Create a queue and a set to keep track of the nodes that we have seen
		const queue = [];
		const seen = new Set()
	
      queue.push(start)
      seen.add(start)
      // TODO Remember to start from the start queue, and make it as seen
      
      let steps = 0;
  
      while (queue.length > 0) {
        const nodesInQueue = queue.length;
  
        for (let j = 0; j < nodesInQueue; j++) {
          const node = queue.shift();
  
          if (node === end) {
            return steps;
          }
  
          for (const c of ['A', 'C', 'G', 'T']) {
            for (let i = 0; i < node.length; i++) {
              const neighbor =
                node.substring(0, i) + c + node.substring(i + 1);
  
              if (!seen.has(neighbor) && bank.includes(neighbor)) {
                queue.push(neighbor);
                seen.add(neighbor);
              }
            }
          }
        }
  
        steps++;
      }
  
      return -1;
    }
  }
  
  module.exports = { Problem: MinMutation };
  
```



```
class RotateImage {

    /**
     * Time O(ROWS * COLS) | Space O(1)
     * https://leetcode.com/problems/rotate-image/
     * @param {number[][]} matrix
     * @return {void} Do not return anything, modify matrix in-place instead.
     */
    rotate = (matrix) => {



        var transpose = (matrix) => {
        
            const rows = matrix.length;

            for (let row = 0; (row < rows); row++) {/* Time O(ROWS) */
                for (let col = (row + 1); (col < rows); col++) {/* Time O(COLS) */
                    swap1(matrix, row, col);
                }
            }
        };

        var swap1 = (matrix, row, col) => [matrix[row][col], matrix[col][row]] = [matrix[col][row], matrix[row][col]];


        var reflect = (matrix) => {
            // TODO Create reflection which finds the reflection using the rows max minus the columns muved -1. 
            // This should only happen if the column is less than the rows / 2.

        }

        var swap2 = (matrix, row, col, reflection) => [matrix[row][col], matrix[row][reflection]] = [matrix[row][reflection], matrix[row][col]];

        transpose(matrix);/* Time O(ROWS * COLS) */
        reflect(matrix);  /* Time O(ROWS * COLS) */
    };


    solve(matrix) {
        return this.rotate(matrix);
    }
}


module.exports = { Problem: RotateImage };
```


```
class RotateImage {

    /**
     * Time O(ROWS * COLS) | Space O(1)
     * https://leetcode.com/problems/rotate-image/
     * @param {number[][]} matrix
     * @return {void} Do not return anything, modify matrix in-place instead.
     */
    rotate = (matrix) => {



        var transpose = (matrix) => {
        
            const rows = matrix.length;

            for (let row = 0; (row < rows); row++) {/* Time O(ROWS) */
                for (let col = (row + 1); (col < rows); col++) {/* Time O(COLS) */
                    swap1(matrix, row, col);
                }
            }
        };

        var swap1 = (matrix, row, col) => [matrix[row][col], matrix[col][row]] = [matrix[col][row], matrix[row][col]];


        var reflect = (matrix) => {
            // TODO Create reflection which finds the reflection using the rows max minus the columns muved -1. 
            // This should only happen if the column is less than the rows / 2.

        }

        var swap2 = (matrix, row, col, reflection) => [matrix[row][col], matrix[row][reflection]] = [matrix[row][reflection], matrix[row][col]];

        transpose(matrix);/* Time O(ROWS * COLS) */
        reflect(matrix);  /* Time O(ROWS * COLS) */
    };


    solve(matrix) {
        return this.rotate(matrix);
    }
}


module.exports = { Problem: RotateImage };
```




