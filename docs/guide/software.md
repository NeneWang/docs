
## 1 Practicing Algorithms Daily

- Is likely that you wont be using algorithms on your job (or at least not in the hard complexity ones.)
  - But on your journey to learning algorithms, You will learn the skill of problem solving throguht pattern recognition.
  - This is a significantly useful skill, as in software following patterns for solutions leads to optimized, mantainable, efficient strategies based where you can share and have at the same time an efficient solution.
- If you havent started, go throguht the 150 recommended lists.
  - Give yourself 20-30 minutes to struggle with the problem
  - Watch a video/editorial solution for it. (even if you were able to solve it) 
  - Dont prioritize learning the most optimal solution, but the solution that uses the `pattern` you are aiming to understand. Tackle the pattern > Tackle the most efficient way to solve it. 
  - Try replicating the solution from memory
  - Do 1 similar problem. (easier is okay) The idea is for you to **understand** that pattern.
- Once you complete 150


## 2 Practice DataScience + Machine Learning Daily

- I dont care if this is wasn't your original goal. If you dont do it, you will eventually be replaced by someone who does.
- Also a strong skill to have for your own projects and if you will start a business.


### Projects

- [Ideation]: Presentation Trainer Tool. 



## 3 How to successfully learn a Framework/Language

    When do you consider yourself good at a language?
  - Because you can create a project with that? No
  - Because you have a job with that? No
  - Because you can solve problems with that? No
  - But because you can really understand whats the reason that language/framework and whats the cycle and context that langauge/framework/environment supports and the best practices on it.

- When you are using a language framework, always try to learn it's best practices
- Otherwise you are not really learning the `pattern` of the language.
- This usually involves:

2. Best Practices goals

- File Structure
  - Usually because of a reason, where do you organize components/ Whats the hierarchy of files? What files to ignore, where to write your environment variables, etc.
- Naming Conventions
  - Key, do it use camelCase? PascalCase? snake_case? kebab-case? What are the best practices for naming variables, functions, classes, etc.
- Code Style
  - How are classes organized? How are functions organized? How are variables organized? How are comments organized?
- Testing
  - Whats the CD CI Pipeline strategy for this framework? Is this more of an UI testing? Unit testing? No testing? Whats the best practice when it comes to organizing
- Documentation Strategy 
    - Deployment Strategy. Many languages allow for in-code documentation, to auto-produce documentation files. Take advantage of that. Try to use that support on each language/framework.
    - Different Languages have different documentation strategies that are optimized for that tool's objective, be it building visual components, enhancing test documentation, etc.
- Development Cycles Practices for that language/framework
  - Whats the initial mock and requirement listing 
- Common Design Patterns on that language.
  - Whats the pattern used for that language in specific? Why that design pattern helps?

3. Steps of the mastery of frameworks:
   1. Create a project with that framework
   2. Master the best practices of that framework in one project
   3. Finish 10 Advanced guide (or a book worth of content) of that framework (or language)
      1. [Exhibit 1: Advanced Git: Merging vs Rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)
      2. [Exhibit 2: Real Python Advanced](https://realpython.com/tutorials/advanced/)
   4. Create a library for that Framework (It can be forking, and creating at least 1 feature there.)
  




## 4 Going through Trainning as an Engineer Mentality


1. College courses, bootcamp, online course follow the following pattern
2. Develop Flashcards based on the best practices listed above so you dont forget them.
3. Create tasks cards for future practice so that you can train yourself into using those cases.
   - For example you are learning react, you should create a card and git repo for a project start and how the project should look at the project finish.
   - For data sicnece you should allow for the same project ideation style.
4. If you are doing a Masters/Phd then for each of the classes you should contribute on an open source project related to that class. (Creating your own is okay)



### Project

- Presentation Task Oriented Tool for [3]:
  - This tool should allow for users to create their own tasks.
  - Time limit them so that a task 
  - When creating a task
    - Suggested time limitation for the task

- Mastery CLI for [2]
  - Should be able to share their deck of cards.
  - Should be allowed for free




## 5 Building a reputation for Consistency

- 1. You should be able to show that you are consistent in your work and software that contains heatmaps or streak recordings are usually one of the bests.
- 2. Use github, publish almost daily, participate on projects, create followers, follow me, I will follow you automatically.
- 3. Use Leetcode, publish daily, dont be like me that didnt use that much, because of fear of not being able to use them. 
- 4. Message your boss at least once, and each member of the team, invent an excuse, any works
  - Design thoughts.
  - A new library you found that might be applicable.




## 6 Passively Learning Cyber Security + IT

*The idea is to passively getting better at cybersecurity. You might not need to implement the securities measures all the time. My suggestion would be to write this audits every 2-5 sprints. (Or once the software has been made into a stabilized)*


1. Regularly Documenting Vulnerabilities.
- When learning a framework, or developing software, you should at the same time, practice cybersecutiy, by mantianning a log/documentation of the potential vulnerabilities of the system. e.g. Putting yourself in a hacker's shoes. How would you hack your own system?
- Where to find the API keys?
- How would you access infomration you are not supposed to?
- How could I ssh this? How could I spoof a user admin?
- What scripts could I write to automate the process of hacking this system?
- What are the key people that could be targeted in this system? What kind of emails could be used?


2. Learn the basics of Cybersecurity
   - Google Certificate.
   - Codepath, certificate.
  

Then continue by writting down the possible solutions to those vulnerabilities. The thing about this, is that you should create checklists based on what you learn from the basics, *lenses* that you should use on your own software. (Patterns of vulnerabilities)


3. Cybersecurity is constantly changing, therefore is not worth, actively pursuing such, but is worth *actively* pursuing software developmenet with an eye on your defenses and vulnerabilities. Grow by understanding commonly used tools + patterns of vulnerabilities. And then using this tools in a cycle to audit your own software.




## 6 Passion Projects

Key points:
- Documentate for Explainning
- Encapsulate Templates for Reusability
- Building Libraries shows expertise of that framework (usually)

Why?
- You need to get paid
- You can increase your popularity by making reusable code (Also a good talking point).

1. Make software Projects that can be shown to recru
   1. Keep in readme the sets of Install options and descriptions with pictures and captures of it's features.
   2. Create a `highlight.md` file tracking the progression of your software and HIGHLIGHT whenever you face an interesting challange.
2.  Once you have a project done, dont let it stay like that, build a library/template out of it.
    1. The entire project doesn't require to become a library, but aim to create a library from one of the complex parts of the project.
    2. And attempt if you have not yet, create a template (for Hackathons or other similar organizations) by abstracting the project into a template.
    3. Make reference of the third tools that you created out of them.
    4. Logic Abstaction: Perhaps the Logic can be abstracted into an API, or a graphing terminal tol can be abstracted into a terminal package.
    5. Architecture Abstraction: Perhaps the authentication System can be abstracted.
    6. UI Abstraction: Perhaps the UI can be abstracted into an UI library.


## 7. Language Mastery

Here 3 layers for the mastery of that Language:

1. Build a project with that language
2. Finish 1 leetcode problem (easy) of each pattern using that language
3. Finish 1 leetcode problem (medium) of each pattern using that language
4. Fork and create an open source library for that language (raw, it can be forked, thats okay)


Once you are able to complete the 3 layers, you can consider yourself a master of that language. 


## 8. Work and Personal Projects

If you were to follow this commandmnets, no matter the pay, you would still be increasing your knowledge worth and also have a interestingly perhaps profittable side project.
- As well as a non-binded project that you could use to show your skills to your future employer.

1. You should strive to build your own `mini-scaled` version on your personal project of the software you are working on at work.
   1. Your objective here is not to biuld the competition, but actually make more insight s to also become better at your `job`.
   2. Here you will have the liberty of exploring your own algorithms and libraries.
   3. Try if you can, to consider using your own models (based on your prefferences)
   4. Use your job also as a learning opportunity to learn the best practices of the language and framework you are using.
   5. Also you wouldn't need to worry about the constant business requirmenet changes.




## 9. Taking your Company success personally

*Recommended for once you have 1-2 yoe. This is the real mastery of your tasks before anything else. And then using that to leverage your voice inside of the decision mking.*

1. Instead of living a life of trying to jump ships. There is something very interesting about the software engineer role in the position.
   1. This means, taking a higher higher risks, suggesting and making bold responsabilities claims.
2. Before you talk you need to build-up your credentials:
   1. Ensure that your code is fully tested/rid of bugs. (Do your job perfectly.)
   2. Make sure your code is fully documented (diagrams, naming conventions, etc)
   3. Empty the bucket of tasks to be done.
   4. Always prepare a looking-forward feature suggestion presentation with you.
3. This is a second layer of to-dos, once the above is done. Which is proactive.
   1. Prepare for certifications related to the technology or framework being touched
   2. Attempt to contribute open-source, forking, and making templates/libraries depending on the indsutry needs of that project.









