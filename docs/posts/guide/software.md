---
title: Mastery of Software Development
---



## 1 Master Algorithms Daily

- 1. Is likely that you wont be using algorithms on your job (or at least not in the hard complexity ones.)
  - But on your journey to learning algorithms, You will learn the skill of problem solving through pattern recognition.
  - This is a significantly useful skill, as in software following patterns for solutions leads to optimized, maintainable, efficient strategies based where you can share and have at the same time an efficient solution.
- 2. If you haven't started, go through the 150 recommended lists.
  - Give yourself 20-30 minutes to struggle with the problem
  - Watch a video/editorial solution for it. (even if you were able to solve it) 
  - Don't prioritize learning the most optimal solution, but the solution that uses the `pattern` you are aiming to understand. Tackle the pattern > Tackle the most efficient way to solve it. 
  3. Try replicating the solution from memory then Go to 
    - Do 1 similar problem. (easier is okay) The idea is for you to **understand** that pattern.
- 4. Once you complete 150 go to daily algorithmic problems.
- 5. Study and Document the most Impactful Algorithms used on the industry, Note below a project to take you to key algorithms


**Projects**


For [5] Consider the following key-algorithms. Learn them by heart by documenting, doing charts.

Sources
http://www.koutschan.de/misc/algorithms.php


**Some of the key Algorithms Areas**

- Machine learning and Optimization
  - Gradient Descent
  - Genetic Algorithms
- Database Algorithms
  - BTree and B+ Tree
  - Consistent Hashing
- Cryptography
- Sorting and Searching
  - Quicksort 
  - Binary Search Tree Algorithm
- Graph Algorithms
- Data Compression
  - Lempel Ziv Welch
  - Brotli
- Optimization and Scheduling
  - Simulated Annealing
  - Linear Programming
- Artificial Intelligence
  - Hidden Markov Models
  - BERT (Bidirectional Encoder Representations from Transformers)
- Languge Processing
- Data Structures and Algorthms
  - Red Black Trees
  - Bloom filters
- Cryptographic and Blockchain
  - Elliptic Curve Cryptography (ECC)
  - Blockchain Consensus Algorithms
- Computational Geometric and Graphics
  - Ray Tracing Algorithms
  - Maarching Cubes Algorithms
- Distributed Computing and Systems
  - Map Reduce
  - Paxos Algorithms

- Euclid
- nicomachus examples
- Sieve of Eratosthenes
- QR Algorithms for Computing Eigenvalues
- Quicksort
- heapsort
- jpeg compression
- Fast Fourier Transform
- Dijikstra Algorithm
- RSA Algorithm
- Secure Hash Algorithm
- Integer Factorization
- Link Analysis
- Proportional Integral Derivative Algorithm
- Data Compression Algorithms
- Random Number Generation
- A* Search Algorithm
- Beam Search
- Binary Search
- Branch and Bound
- Bunchberger's Algorithm
- Data Compression
- Diffie-Hellman Key Exchange
- Discrete Differentiation
- Expectation Maximization Algorithm
- Gradient Descent
- Hashing
- Heap Sort
- Karatsuba Multiplication
- LLL Algorithm
- Maximum Flow
- Newton's Method
- Merge Sort
- Q-Learning
- Quadratic Sive
- RANSAC
- Schohange Strassen Algorithm
- Simplex Algorithm
- Singular Value Decomposition
- Strukturtensor
- Union Find.
- Viterbi Algorihtm
- KNN
- Random Forest
- Naive Bayes
- Neural Network
- Monte Carlo
- MapReduce



Try doing all problems in:

```
C++
Java
Python
```

Why? Cause you need to practice those languages. Absolutely. You should consider doing all again (the 150 list) again in Java or C++




## 2 Master  Data Science + Machine Learning Daily

- I dont care if this is wasn't your original goal. If you dont do it, you will eventually be replaced by someone who does.
- Also a strong skill to have for your own projects and if you will start a business.


### Projects

- [Ideation]: Presentation Trainer Tool. 



## 3 How to successfully learn a Framework/Language

    When do you consider yourself good at a language?
  - Because you can create a project with that? No
  - Because you have a job with that? No
  - Because you can solve problems with that? No
  - But because you can really understand whats the reason that language/framework and whats the cycle and context that langauge/framework/environment supports and the best practices on it.

- When you are using a language framework, always try to learn it's best practices
- Otherwise you are not really learning the `pattern` of the language.
- This usually involves:

2. Best Practices goals

- File Structure
  - Usually because of a reason, where do you organize components/ Whats the hierarchy of files? What files to ignore, where to write your environment variables, etc.
- Naming Conventions
  - Key, do it use camelCase? PascalCase? snake_case? kebab-case? What are the best practices for naming variables, functions, classes, etc.
- Code Style
  - How are classes organized? How are functions organized? How are variables organized? How are comments organized?
- Testing
  - Whats the CD CI Pipeline strategy for this framework? Is this more of an UI testing? Unit testing? No testing? Whats the best practice when it comes to organizing
- Documentation Strategy 
    - Deployment Strategy. Many languages allow for in-code documentation, to auto-produce documentation files. Take advantage of that. Try to use that support on each language/framework.
    - Different Languages have different documentation strategies that are optimized for that tool's objective, be it building visual components, enhancing test documentation, etc.
- Development Cycles Practices for that language/framework
  - Whats the initial mock and requirement listing 
- Common Design Patterns on that language.
  - Whats the pattern used for that language in specific? Why that design pattern helps?

3. Steps of the mastery of frameworks:
   1. Create a project with that framework
   2. Master the best practices of that framework in one project
   3. Finish 10 Advanced guide (or a book worth of content) of that framework (or language)
      1. [Exhibit 1: Advanced Git: Merging vs Rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)
      2. [Exhibit 2: Real Python Advanced](https://realpython.com/tutorials/advanced/)
   4. Create a library for that Framework (It can be forking, and creating at least 1 feature there.)
  




## 4 Going through Trainning as an Engineer Mentality


1. College courses, bootcamp, online course follow the following pattern
2. Develop Flashcards based on the best practices listed above so you dont forget them.
3. Create tasks cards for future practice so that you can train yourself into using those cases.
   - For example you are learning react, you should create a card and git repo for a project start and how the project should look at the project finish.
   - For data sicnece you should allow for the same project ideation style.
4. If you are doing a Masters/Phd then for each of the classes you should contribute on an open source project related to that class. (Creating your own is okay)



### Project

- Presentation Task Oriented Tool for [3]:
  - This tool should allow for users to create their own tasks.
  - Time limit them so that a task 
  - When creating a task
    - Suggested time limitation for the task

- Mastery CLI for [2]
  - Should be able to share their deck of cards.
  - Should be allowed for free




## 5 Building a reputation for Consistency

- 1. You should be able to show that you are consistent in your work and software that contains heatmaps or streak recordings are usually one of the bests.
- 2. Use github, publish almost daily, participate on projects, create followers, follow me, I will follow you automatically.
- 3. Use Leetcode, publish daily, dont be like me that didnt use that much, because of fear of not being able to use them. 
- 4. Message your boss at least once, and each member of the team, invent an excuse, any works
  - Design thoughts.
  - A new library you found that might be applicable.




## 6 Passively Learning Cyber Security + IT

*The idea is to passively getting better at cybersecurity. You might not need to implement the securities measures all the time. My suggestion would be to write this audits every 2-5 sprints. (Or once the software has been made into a stabilized)*


1. Regularly Documenting Vulnerabilities.
- When learning a framework, or developing software, you should at the same time, practice cybersecutiy, by mantianning a log/documentation of the potential vulnerabilities of the system. e.g. Putting yourself in a hacker's shoes. How would you hack your own system?
- Where to find the API keys?
- How would you access infomration you are not supposed to?
- How could I ssh this? How could I spoof a user admin?
- What scripts could I write to automate the process of hacking this system?
- What are the key people that could be targeted in this system? What kind of emails could be used?


2. Learn the basics of Cybersecurity
   - Google Certificate.
   - Codepath, certificate.
  

Then continue by writting down the possible solutions to those vulnerabilities. The thing about this, is that you should create checklists based on what you learn from the basics, *lenses* that you should use on your own software. (Patterns of vulnerabilities)


3. Cybersecurity is constantly changing, therefore is not worth, actively pursuing such, but is worth *actively* pursuing software developmenet with an eye on your defenses and vulnerabilities. Grow by understanding commonly used tools + patterns of vulnerabilities. And then using this tools in a cycle to audit your own software.




## 6 Passion Projects

Key points:
- Documentate for Explainning
- Encapsulate Templates for Reusability
- Building Libraries shows expertise of that framework (usually)

Why?
- You need to get paid
- You can increase your popularity by making reusable code (Also a good talking point).

1. Make software Projects that can be shown to recru
   1. Keep in readme the sets of Install options and descriptions with pictures and captures of it's features.
   2. Create a `highlight.md` file tracking the progression of your software and HIGHLIGHT whenever you face an interesting challange.
2.  Once you have a project done, dont let it stay like that, build a library/template out of it.
    1. The entire project doesn't require to become a library, but aim to create a library from one of the complex parts of the project.
    2. And attempt if you have not yet, create a template (for Hackathons or other similar organizations) by abstracting the project into a template.
    3. Make reference of the third tools that you created out of them.
    4. Logic Abstaction: Perhaps the Logic can be abstracted into an API, or a graphing terminal tol can be abstracted into a terminal package.
    5. Architecture Abstraction: Perhaps the authentication System can be abstracted.
    6. UI Abstraction: Perhaps the UI can be abstracted into an UI library.


## 7. Language Mastery

Here 3 layers for the mastery of that Language:

1. Build a project with that language
2. Finish 1 leetcode problem (easy) of each pattern using that language
3. Finish 1 leetcode problem (medium) of each pattern using that language
4. Fork and create an open source library for that language (raw, it can be forked, thats okay)


Once you are able to complete the 3 layers, you can consider yourself a master of that language. 


## 8. Work and Personal Projects

If you were to follow this commandmnets, no matter the pay, you would still be increasing your knowledge worth and also have a interestingly perhaps profittable side project.
- As well as a non-binded project that you could use to show your skills to your future employer.

1. You should strive to build your own `mini-scaled` version on your personal project of the software you are working on at work.
   1. Your objective here is not to biuld the competition, but actually make more insight s to also become better at your `job`.
   2. Here you will have the liberty of exploring your own algorithms and libraries.
   3. Try if you can, to consider using your own models (based on your prefferences)
   4. Use your job also as a learning opportunity to learn the best practices of the language and framework you are using.
   5. Also you wouldn't need to worry about the constant business requirmenet changes.




## 9. Taking your Company success personally

*Recommended for once you have 1-2 yoe. This is the real mastery of your tasks before anything else. And then using that to leverage your voice inside of the decision mking.*

1. Instead of living a life of trying to jump ships. There is something very interesting about the software engineer role in the position.
   1. This means, taking a higher higher risks, suggesting and making bold responsabilities claims.
2. Before you talk you need to build-up your credentials:
   1. Ensure that your code is fully tested/rid of bugs. (Do your job perfectly.)
   2. Make sure your code is fully documented (diagrams, naming conventions, etc)
   3. Empty the bucket of tasks to be done.
   4. Always prepare a looking-forward feature suggestion presentation with you.
3. This is a second layer of to-dos, once the above is done. Which is proactive.
   1. Prepare for certifications related to the technology or framework being touched
   2. Attempt to contribute open-source, forking, and making templates/libraries depending on the indsutry needs of that project.



## 10. Continuous Testing at your advantage.


How to develop  an unfair Advantage?

> The reason why they require 3+ years of experience is that 3+ years of experience behind a laptop coding everyday creates an unfair advantage. It naturally makes you mountains of mastery stronger than someone who has not been coding everyday for 3+ years. Now, How can I integrate that into your career philosophy?

- 



*Use a continuous testing philosophy to advance on your knowledge (advanced technical) passively*

This includes the following: ranked.

| Topic                                                | Value Est. |
| ---------------------------------------------------- | ---------- |
| Study for certifications: aws, certifications        | 9          |
| Interview questions of specific language/technology  | 9          |
| Introduction to algorithms                           | 8          |
| Machine learning                                     | 8          |
| Programming Best Practices: Design Patterns, Testing | 7          |



Here so guidelines into building great flashcards:

- They dont ask you the definition, but how could you use X technology
- If it is about implementation, provides an example of how to implement it (use it for refreshing a tech aspect)



## 11. Documentation 


1. Attempt to follow auto documentation for each langauge format of documentation (close to code for methods)
2. Keep a datastructure table excel or draw.io with also how classes interact with each, and responsabilities. (Note you can have the following also as a single Google docs, if it is easier. (Always try to keep thing stogether/))
   1. Google Sheet Tab with table with Tests.
   2. Google sheet Tab with features, coverage to have, difficulty, KPI, Need matrix, Status, Catgory (e.g. template, Third party.)
   3. Google Sheet Tab with each datastructure and database models being used.
   4. Google Sheet Tab with API documentation and implementation.
3. Keep **highlight** section for story telling of this project. 
4. Keep futureistic as possible the readme with even features it doesn't have. But you are planning to have. (for visitors mostly)
5. Dcoument deployment with dockerfile/makefile in code.
6. For Database Models, always go for keeping a coded model, so you can write comments regarding each change and run migrations automatically.




