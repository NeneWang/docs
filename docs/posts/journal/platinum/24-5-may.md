

### 16 Log


### Working on understanding Snowflake


https://www.youtube.com/watch?v=xCCkHZf1-aI

![](../../../../img/Pasted%20image%2020240516123657.png)

- How did it even display the thing?


- How did it find the data at the first place?
```SQL
COPY INTO company_metadata FROM @cybersyn_company_metadata file_format=csv PATTERN = '.*csv.*' ON_ERROR = 'CONTINUE';
```





File Formatted for ingesting:

```
File format for ingesting data for zero to snowflake
```

So here basically what happened is that I defined the format of CSV, created the options

Then runned a copy argument to copy to staging and then it would reprocess the staging file.



Objective is not only to be able to run Snowflake, but also getting good at optimizing queries and costs.




:ets gp pver qieruomg 




















Auto Stress Tester
- Defines parameters in
- Defines Breaking Cases
- Creates tests automatically using random
- Creates other tests automatically Using AI
- Computes charts and performance draws
- for js logic components
- Auto guess input type and range also activated.





Graph Algorithm Visualizer Component

- Very simple, as stated, you pass an history, and has already precreated rules on tables, etc. to automatically display things.
- Also should support things such as grid displays
- Tree Displays
- Auto generate based on input makes sense for lists, or tree based.
- Modify the code for the charter solely for this purpose
- Animation specific
- Allows adding and removing nodes in real time.
- Allows for examples switch between datasets.




GPT Based Documenter and Up keeper

- Similar to Delvin AI.
- Upkeeps documentation
- Upkeeps tests.
- Upkeeps dependency.
- Tracks Feature Changelogs

### 17

For now we are simulating the sqs body:
I think a Python driver in this case makes a lot of sense.
https://docs.snowflake.com/en/developer-guide/python-connector/python-connector-example
- Upper and other methods:
- Upper: https://docs.snowflake.com/en/sql-reference/functions/upper
- Can you have `s3` loaded by python in snowflake?

https://docs.snowflake.com/en/developer-guide/snowpark/python/python-worksheets

Here it shows how you can install packages as well:

- https://docs.snowflake.com/en/developer-guide/snowpark/python/python-worksheets#label-snowsight-py-worksheets-start

  
![](../../../../img/Pasted%20image%2020240517141710.png)


- Add your own packages and Python files by selecting Stage Packages and specifying the file path of the stage and package, then selecting Import. See [Add a Python File from a Stage to a Worksheet](https://docs.snowflake.com/en/developer-guide/snowpark/python/python-worksheets#label-snowsight-py-worksheets-add-py-file).
https://repo.anaconda.com/pkgs/snowflake/

![](../../../../img/Pasted%20image%2020240517141952.png)

python Streamlit loading csv using queries vs boto3?


![](../../../../img/Pasted%20image%2020240517142808.png)

Pros not using Stage: I think the advantage here is that there wouldn't be any stage tables.



## 21 

### 1. Progressing on the Snowflake

### 2. Building Better Docs and Fixing Visualizations.

- [x] Adding Visualizations
- [ ] Looking for approval of the method whenever this is possible.



```
SELECT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(t.$23) AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM TEST.PUBLIC.CONNECTICUT t
    LIMIT 19
```

![](../../../../img/Pasted%20image%2020240527161900.png)

Lets see what's on 19nth

An end_date is new here
![](../../../../img/Pasted%20image%2020240527162011.png)



```

    SELECT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM TEST.PUBLIC.CONNECTICUT t
    LIMIT 20
```

It seems that at row 14:

![](../../../../img/Pasted%20image%2020240527165800.png)

We have a problem with insertion. Where gets duplicated at around number 12-20 rows.

Oh look at that, is duplicated.

![](../../../../img/Pasted%20image%2020240527170056.png)

Working query:

```

MERGE INTO CORPORATION AS corp
USING (
    SELECT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM TEST.PUBLIC.CONNECTICUT t
    LIMIT 100
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);

```




Select

```sql
SELECT
    $1 AS pf_id,
    CONCAT('CT', '_', $2) AS pf_state_corpid,
    'CT' AS pf_state,
    $2 AS corporation_id,
    $15 AS entity_email,
    $2 AS corporation_name,
    $9 AS entity_address_1,
    $10 AS entity_address_2,
    $11 AS entity_city,
    $14 AS entity_state,
    $19 AS creation_date,
    $23 AS end_date,
    $13 AS entity_zip,
    $12 AS entity_country,
    $4 AS status,
    $40 AS naics,
    $41 AS naics_subcode,
    $7 AS annual_report_due_date,
    'Your_Source_File_GUID_Here' AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
FROM TEST.PUBLIC.CONNECTICUT LIMIT 100
```


Select Distinct

```sql
SELECT DISTINCT
    t.$1 AS pf_id,
    CONCAT('CT', '_', t.$2) AS pf_state_corpid,
    'CT' AS pf_state,
    t.$2 AS corporation_id,
    t.$15 AS entity_email,
    t.$2 AS corporation_name,
    t.$9 AS entity_address_1,
    t.$10 AS entity_address_2,
    t.$11 AS entity_city,
    t.$14 AS entity_state,
    TO_DATE(t.$19) AS creation_date,
    TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
    t.$13 AS entity_zip,
    t.$12 AS entity_country,
    t.$4 AS status,
    t.$40 AS naics,
    t.$41 AS naics_subcode,
    t.$7 AS annual_report_due_date,
    'CT' AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
FROM TEST.PUBLIC.CONNECTICUT t
LIMIT 100;

```

Select distinct:

```sql

MERGE INTO CORPORATION AS corp
USING (
    SELECT DISTINCT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM TEST.PUBLIC.CONNECTICUT t
    LIMIT 100
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);
```




![](../../../../img/Pasted%20image%2020240527173103.png)

```
SELECT src.*, c.*
FROM (
    SELECT DISTINCT
        t.$2 AS corporation_id
    FROM TEST.PUBLIC.CONNECTICUT t
    LIMIT 100
) AS src
LEFT JOIN TEST.PUBLIC.CONNECTICUT tl;

```


```
SELECT src.*, c.*
FROM (
    SELECT DISTINCT
        t.$2 AS corporation_id
    FROM TEST.PUBLIC.CONNECTICUT t
    LIMIT 100
) AS src
LEFT JOIN (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY corporation_id ORDER BY pf_loaded_date DESC) AS row_num
    FROM TEST.PUBLIC.CONNECTICUT
) AS c ON src.corporation_id = c.corporation_id AND c.row_num = 1;

```

```sql
MERGE INTO CORPORATION AS corp
USING (
    SELECT DISTINCT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM (
        SELECT *,
               ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY pf_loaded_date DESC) AS row_num
        FROM TEST.PUBLIC.CONNECTICUT
    ) AS t
    WHERE t.row_num = 1
    LIMIT 100
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);


```


Merge INTO with the SELECT MERGE INTO

```sql
MERGE INTO CORPORATION AS corp
USING (
    SELECT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM (
        SELECT *,
               ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY CURRENT_TIMESTAMP() DESC) AS row_num
        FROM TEST.PUBLIC.CONNECTICUT
    ) AS t
    WHERE t.row_num = 1
    LIMIT 100
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);


```

It doesn't look like it did a lot of insertions did it?

![](../../../../img/Pasted%20image%2020240527174714.png)


Which makes sense:

![](../../../../img/Pasted%20image%2020240527174907.png)

Now when trying using the real stage:

![](../../../../img/Pasted%20image%2020240527180147.png)

```
MERGE INTO CORPORATION AS corp
USING (
    SELECT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM (
        SELECT *,
               ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY CURRENT_TIMESTAMP() DESC) AS row_num
        FROM PFCOMPANIES.PUBLIC.CORPORATION
    ) AS t
    WHERE t.row_num = 1
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);

```

```sql
SELECT DISTINCT
    t.$1 AS pf_id,
    CONCAT('CT', '_', t.$2) AS pf_state_corpid,
    'CT' AS pf_state,
    t.$2 AS corporation_id,
    t.$15 AS entity_email,
    t.$2 AS corporation_name,
    t.$9 AS entity_address_1,
    t.$10 AS entity_address_2,
    t.$11 AS entity_city,
    t.$14 AS entity_state,
    TO_DATE(t.$19) AS creation_date,
    TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
    t.$13 AS entity_zip,
    t.$12 AS entity_country,
    t.$4 AS status,
    t.$40 AS naics,
    t.$41 AS naics_subcode,
    t.$7 AS annual_report_due_date,
    'CT' AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
FROM PFCOMPANIES.PUBLIC.CT t
LIMIT 100;
```



This fails because of the header:

The header here:

```sql

CREATE OR REPLACE FILE FORMAT csvformat TYPE = 'csv' FIELD_DELIMITER = ',';


SELECT t.$1 t.$2 FROM PFCOMPANIES.PUBLIC.CT (file_format => csvformat) t;

```


PARSE_HEADER
`PARSE_HEADER = TRUE | FALSE`

Use

Data loading only

Definition

Boolean that specifies whether to use the first row headers in the data files to determine column names.

This file format option is applied to the following actions only:

> - Automatically detecting column definitions by using the INFER_SCHEMA function.
>     
> - Loading CSV data into separate columns by using the INFER_SCHEMA function and MATCH_BY_COLUMN_NAME copy option.
>     

If the option is set to TRUE, the first row headers will be used to determine column names. The default value FALSE will return column names as c*, where * is the position of the column.

Note that the SKIP_HEADER option is not supported with PARSE_HEADER = TRUE.

Default: `FALSE`

---
`SKIP_HEADER = _integer_`

Use

Data loading and external tables

Definition

Number of lines at the start of the file to skip.

Note that SKIP_HEADER does not use the RECORD_DELIMITER or FIELD_DELIMITER values to determine what a header line is; rather, it simply skips the specified number of CRLF (Carriage Return, Line Feed)-delimited lines in the file. RECORD_DELIMITER and FIELD_DELIMITER are then used to determine the rows of data to load.

Default


Then it would result in:

```SQL
CREATE OR REPLACE FILE FORMAT csv
    TYPE = 'CSV'
    COMPRESSION = 'AUTO'  -- Automatically determines the compression of files
    FIELD_DELIMITER = ','  -- Specifies comma as the field delimiter
    RECORD_DELIMITER = '\n'  -- Specifies newline as the record delimiter
    SKIP_HEADER = 0  -- No headers to skip, starts reading from the first line
    FIELD_OPTIONALLY_ENCLOSED_BY = '\042'  -- Fields are optionally enclosed by double quotes (ASCII code 34)
    TRIM_SPACE = FALSE  -- Spaces are not trimmed from fields
    ERROR_ON_COLUMN_COUNT_MISMATCH = FALSE  -- Does not raise an error if the number of fields in the data file varies
    ESCAPE = 'NONE'  -- No escape character for special character escaping
    ESCAPE_UNENCLOSED_FIELD = '\134'  -- Backslash is the escape character for unenclosed fields
    DATE_FORMAT = 'AUTO'  -- Automatically detects the date format
    TIMESTAMP_FORMAT = 'AUTO'  -- Automatically detects the timestamp format
    NULL_IF = ('')  -- Treats empty strings as NULL values
    COMMENT = 'File format for ingesting data for zero to snowflake';
```

This results however in:

![](../../../../img/Pasted%20image%2020240528093418.png)

---

```

```sql


SELECT
    t.$1 AS pf_id,
    CONCAT('CT', '_', t.$2) AS pf_state_corpid,
    'CT' AS pf_state,
    t.$2 AS corporation_id,
    t.$15 AS entity_email,
    t.$2 AS corporation_name,
    t.$9 AS entity_address_1,
    t.$10 AS entity_address_2,
    t.$11 AS entity_city,
    t.$14 AS entity_state,
    TO_DATE(t.$19) AS creation_date,
    TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
    t.$13 AS entity_zip,
    t.$12 AS entity_country,
    t.$4 AS status,
    t.$40 AS naics,
    t.$41 AS naics_subcode,
    t.$7 AS annual_report_due_date,
    'CT' AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t LIMIT 10;
```


Successful rows:

```sql
CREATE OR REPLACE FILE FORMAT csvformat
    TYPE = 'CSV'
    COMPRESSION = 'AUTO'  
    FIELD_DELIMITER = ',' 
    RECORD_DELIMITER = '\n'
    SKIP_HEADER=1
    FIELD_OPTIONALLY_ENCLOSED_BY = '\042'  
    TRIM_SPACE = FALSE  
    ERROR_ON_COLUMN_COUNT_MISMATCH = FALSE 
    ESCAPE = 'NONE' 
    ESCAPE_UNENCLOSED_FIELD = '\134'
    DATE_FORMAT = 'AUTO'
    TIMESTAMP_FORMAT = 'AUTO' 
    NULL_IF = ('') 
    COMMENT = 'File format acceptable for CT';

SELECT
    t.$1 AS pf_id,
    CONCAT('CT', '_', t.$2) AS pf_state_corpid,
    'CT' AS pf_state,
    t.$2 AS corporation_id,
    t.$15 AS entity_email,
    t.$2 AS corporation_name,
    t.$9 AS entity_address_1,
    t.$10 AS entity_address_2,
    t.$11 AS entity_city,
    t.$14 AS entity_state,
    TO_DATE(t.$19) AS creation_date,
    TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
    t.$13 AS entity_zip,
    t.$12 AS entity_country,
    t.$4 AS status,
    t.$40 AS naics,
    t.$41 AS naics_subcode,
    t.$7 AS annual_report_due_date,
    'CT' AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t LIMIT 10;
```

```sql
MERGE INTO CORPORATION AS corp
USING (
    SELECT
        t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active
    FROM (
        SELECT *,
               ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY CURRENT_TIMESTAMP() DESC) AS row_num
        FROM PFCOMPANIES.PUBLIC.CORPORATION LIMIT 10
    ) AS t
    WHERE t.row_num = 1
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);


```


Correct query for:

![](../../../../img/Pasted%20image%2020240528095427.png)

> Here it picks corretly based on the row number

```sql
CREATE OR REPLACE FILE FORMAT csvformat
    TYPE = 'CSV'
    COMPRESSION = 'AUTO'  
    FIELD_DELIMITER = ',' 
    RECORD_DELIMITER = '\n'
    SKIP_HEADER=1
    FIELD_OPTIONALLY_ENCLOSED_BY = '\042'  
    TRIM_SPACE = FALSE  
    ERROR_ON_COLUMN_COUNT_MISMATCH = FALSE 
    ESCAPE = 'NONE' 
    ESCAPE_UNENCLOSED_FIELD = '\134'
    DATE_FORMAT = 'AUTO'
    TIMESTAMP_FORMAT = 'AUTO' 
    NULL_IF = ('') 
    COMMENT = 'File format acceptable for CT';


SELECT
    *
FROM (
    SELECT t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active,
       ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY CURRENT_TIMESTAMP() DESC) AS row_num
    FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t LIMIT 100
) t
    WHERE t.row_num = 1




```


You can limit the query if required:

```sql
MERGE INTO CORPORATION AS corp
USING (       
    SELECT
        *
    FROM (
        SELECT t.$1 AS pf_id,
            CONCAT('CT', '_', t.$2) AS pf_state_corpid,
            'CT' AS pf_state,
            t.$2 AS corporation_id,
            t.$15 AS entity_email,
            t.$2 AS corporation_name,
            t.$9 AS entity_address_1,
            t.$10 AS entity_address_2,
            t.$11 AS entity_city,
            t.$14 AS entity_state,
            TO_DATE(t.$19) AS creation_date,
            TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
            t.$13 AS entity_zip,
            t.$12 AS entity_country,
            t.$4 AS status,
            t.$40 AS naics,
            t.$41 AS naics_subcode,
            t.$7 AS annual_report_due_date,
            'CT' AS pf_source,
            CURRENT_TIMESTAMP() AS pf_loaded_date,
            TRUE AS pf_is_active,
           ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY CURRENT_TIMESTAMP() DESC) AS row_num
        FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t 
    ) t
        WHERE t.row_num = 1
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);

```


- Fails at `500 000`
	- It states something about CT is not recognized?
- Fails at `250 000`

![](../../../../img/Pasted%20image%2020240528095952.png)
> Here it seems that `CT` is the problem on the date. 


There is an ON ERROR option

![](../../../../img/Pasted%20image%2020240528100404.png)
> https://community.snowflake.com/s/question/0D50Z000098WaC0SAK/is-it-possible-to-skip-rows-in-a-load

Which might have an equivalent at merge

Doesn't seem to appear such values around:
![](../../../../img/Pasted%20image%2020240528100624.png)



How about WHERE date is not ct?


        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,

So this works:

```sql
FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t WHERE t.$19 !='CT' AND t.$23 !='CT' LIMIT 250000
```

![](../../../../img/Pasted%20image%2020240528101041.png)


![](../../../../img/Pasted%20image%2020240528101110.png)

> Success!

#### Now Nevada


Here is the problem with Nevada in Specific:

![](../../../../img/Pasted%20image%2020240528101300.png)


The latest version is neither correct:
- Reason: I should also incrementally insert in a loop WHERE 1..n of the potential partitions.
Also there has to be a query where it checks for the partitions:

```

```


Should I run the queries multiple times? 
Run a merge across tables? Will it understand things ?


Hypothesis:
- Should be run separately by file: 
	- Reason: 
		- The files otherwise will fall in the Not unique table used problem


- [ ] Add the Stages required
	- [ ] Insert Florida as a state as well.



Here the following questions we have to ask the data about:

- [ ] Is there null in the key ids?
- [ ] Is there duplicates on the same tables?

Can you select where the partition is larger?

![](../../../../img/Pasted%20image%2020240528102843.png)


Since there is no update exactly, the idea should be to select WHERE the row number is larger (Order by row number instead and then select the latest one)

- Assumption the latest copies are the ones at the end: `CT_REFLECTIONS, INC.`

You can see here for example that it creates the latest one here:

![](../../../../img/Pasted%20image%2020240528103537.png)

You want to always keep the latest:

![](../../../../img/Pasted%20image%2020240528103615.png)

Then it should always prioritize Where the date is more recent:

Latest query version:

- Now lets sort by start date. Where latest first But does null be first always?
- Edge case: How does it behave? Does it prioritize where date is null?

```
CREATE OR REPLACE FILE FORMAT csvformat
    TYPE = 'CSV'
    COMPRESSION = 'AUTO'  
    FIELD_DELIMITER = ',' 
    RECORD_DELIMITER = '\n'
    SKIP_HEADER=1
    FIELD_OPTIONALLY_ENCLOSED_BY = '\042'  
    TRIM_SPACE = FALSE  
    ERROR_ON_COLUMN_COUNT_MISMATCH = FALSE 
    ESCAPE = 'NONE' 
    ESCAPE_UNENCLOSED_FIELD = '\134'
    DATE_FORMAT = 'AUTO'
    TIMESTAMP_FORMAT = 'AUTO' 
    NULL_IF = ('') 
    COMMENT = 'File format acceptable for CT';


SELECT
    *
FROM (
    SELECT t.$1 AS pf_id,
        CONCAT('CT', '_', t.$2) AS pf_state_corpid,
        'CT' AS pf_state,
        t.$2 AS corporation_id,
        t.$15 AS entity_email,
        t.$2 AS corporation_name,
        t.$9 AS entity_address_1,
        t.$10 AS entity_address_2,
        t.$11 AS entity_city,
        t.$14 AS entity_state,
        TO_DATE(t.$19) AS creation_date,
        TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
        t.$13 AS entity_zip,
        t.$12 AS entity_country,
        t.$4 AS status,
        t.$40 AS naics,
        t.$41 AS naics_subcode,
        t.$7 AS annual_report_due_date,
        'CT' AS pf_source,
        CURRENT_TIMESTAMP() AS pf_loaded_date,
        TRUE AS pf_is_active,
       ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY TO_DATE(t.$19) DESC) AS row_num
    FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t WHERE t.$19 !='CT' AND t.$23 !='CT' LIMIT 250000
) t
    WHERE t.row_num > 2

```

Which is now the first query when selected

As expected it should only query result as update:
![](../../../../img/Pasted%20image%2020240528103905.png)

```sql
CREATE OR REPLACE FILE FORMAT csvformat
    TYPE = 'CSV'
    COMPRESSION = 'AUTO'  
    FIELD_DELIMITER = ',' 
    RECORD_DELIMITER = '\n'
    SKIP_HEADER=1
    FIELD_OPTIONALLY_ENCLOSED_BY = '\042'  
    TRIM_SPACE = FALSE  
    ERROR_ON_COLUMN_COUNT_MISMATCH = FALSE 
    ESCAPE = 'NONE' 
    ESCAPE_UNENCLOSED_FIELD = '\134'
    DATE_FORMAT = 'AUTO'
    TIMESTAMP_FORMAT = 'AUTO' 
    NULL_IF = ('') 
     DATE_FORMAT =  AUTO
     TIME_FORMAT =  AUTO
    COMMENT = 'File format acceptable for CT';



MERGE INTO CORPORATION AS corp
USING (       
    SELECT
        *
    FROM (
        SELECT t.$1 AS pf_id,
            CONCAT('CT', '_', t.$2) AS pf_state_corpid,
            'CT' AS pf_state,
            t.$2 AS corporation_id,
            t.$15 AS entity_email,
            t.$2 AS corporation_name,
            t.$9 AS entity_address_1,
            t.$10 AS entity_address_2,
            t.$11 AS entity_city,
            t.$14 AS entity_state,
            TO_DATE(t.$19) AS creation_date,
            TO_DATE(REPLACE(t.$23, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date,
            t.$13 AS entity_zip,
            t.$12 AS entity_country,
            t.$4 AS status,
            t.$40 AS naics,
            t.$41 AS naics_subcode,
            t.$7 AS annual_report_due_date,
            'CT' AS pf_source,
            CURRENT_TIMESTAMP() AS pf_loaded_date,
            TRUE AS pf_is_active,
           ROW_NUMBER() OVER (PARTITION BY $2 ORDER BY TO_DATE(t.$19) DESC) AS row_num
        FROM @CT (FILE_FORMAT => csvformat, PATTERN => '.*\\.csv') AS t WHERE t.$19 !='CT' AND t.$23 !='CT'
    ) t
        WHERE t.row_num = 1
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_id = src.corporation_id,
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        creation_date = src.creation_date,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);

```



SQL Server treats NULL values as the lowest possible value for a given datatype. This means that **if you specify a column in the ORDER BY clause that has null values in ascending order the NULL values will appear first in the result set**


![](../../../../img/Pasted%20image%2020240528104051.png)

- No worries.



Ok I actually don't understand this

![](../../../../img/Pasted%20image%2020240528112855.png)



Using this example:

https://docs.snowflake.com/en/sql-reference/sql/list

I cant see clearly why the previous was wrong

```sql

LIST @NEVADA PATTERN='.*Crprtn.*'
```

So it should be something as follows:

```sql
SELECT
    UUID_STRING() AS pf_id,
    CONCAT('NV', '_', t.$2) AS pf_state_corpid,
    'CT' AS pf_state,
    t.$2 AS corporation_id,
    t.$7 AS entity_email, -- Assuming t.$7 corresponds to the email field
    t.$7 AS corporation_name, -- Assuming t.$7 corresponds to the corporation name field
    t.$15 AS entity_address_1,
    t.$16 AS entity_address_2,
    t.$17 AS entity_city,
    t.$18 AS entity_state,
    t.$19 AS entity_zip,
    t.$20 AS entity_country,
    t.$5 AS status,
    t.$40 AS naics,
    t.$41 AS naics_subcode,
    TO_DATE(t.$21) AS creation_date, -- Assuming t.$21 corresponds to the creation date field
    TO_DATE(REPLACE(t.$25, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date, -- Assuming t.$25 corresponds to the end date field
    t.$7 AS annual_report_due_date, -- Assuming t.$7 corresponds to the annual report due date field
    'CT' AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
    FROM @NEVADA (FILE_FORMAT => csvformat, PATTERN => '.*Crprtn.*') AS t 
LIMIT 10;

```

It seems there is such thing as metafilename:

```sql
SELECT
    UUID_STRING() AS pf_id,
    CONCAT('NV', '_', t.$2) AS pf_state_corpid,
    'CT' AS pf_state,
    t.$2 AS corporation_id,
    t.$7 AS entity_email, -- Assuming t.$7 corresponds to the email field
    t.$7 AS corporation_name, -- Assuming t.$7 corresponds to the corporation name field
    t.$15 AS entity_address_1,
    t.$16 AS entity_address_2,
    t.$17 AS entity_city,
    t.$18 AS entity_state,
    t.$19 AS entity_zip,
    t.$20 AS entity_country,
    t.$5 AS status,
    t.$40 AS naics,
    t.$41 AS naics_subcode,
    TO_DATE(t.$21) AS creation_date, -- Assuming t.$21 corresponds to the creation date field
    TO_DATE(REPLACE(t.$25, ' AM', ''), 'MM/DD/YYYY HH:MI:SS') AS end_date, -- Assuming t.$25 corresponds to the end date field
    t.$7 AS annual_report_due_date, -- Assuming t.$7 corresponds to the annual report due date field
    METADATA$FILENAME AS pf_source,
    CURRENT_TIMESTAMP() AS pf_loaded_date,
    TRUE AS pf_is_active
    FROM @NEVADA (FILE_FORMAT => csvformat, PATTERN => '.*Crprtn.*') AS t 
LIMIT 10;

```

https://docs.snowflake.com/en/user-guide/querying-metadata


![](../../../../img/Pasted%20image%2020240528114929.png)

You can also have that as the METAFILENAME impressive!
Which is that  you can show or order the merge query as expected with the file row number.


This is actually more useful here:

https://docs.snowflake.com/en/sql-reference/functions/try_to_date

Seems that we can try or fail?


![](../../../../img/Pasted%20image%2020240528120112.png)![](../../../../img/Pasted%20image%2020240528120255.png)

Invalid data type [DATE] for predicate [CAST(T.$21 AS DATE)]
![](../../../../img/Pasted%20image%2020240528120416.png)

Which problem seems to be here as string.

What which row did that even come from?

```
MERGE INTO CORPORATION AS corp
USING (       
      
    SELECT
        *
    FROM (
        SELECT
            UUID_STRING() AS pf_id,
            CONCAT('NV', '_', t.$1) AS pf_state_corpid,
            'NV' AS pf_state,
            t.$1 AS corporation_id,
            t.$7 AS entity_email, 
            t.$7 AS corporation_name, 
            t.$15 AS entity_address_1,
            t.$16 AS entity_address_2,
            t.$17 AS entity_city,
            t.$18 AS entity_state,
            t.$19 AS entity_zip,
            t.$20 AS entity_country,
            t.$5 AS status,
            t.$40 AS naics,
            t.$41 AS naics_subcode,
            TRY_TO_DATE(t.$21) AS creation_date, 
            TRY_TO_DATE(t.$25) AS end_date,
            t.$7 AS annual_report_due_date, 
            METADATA$FILENAME AS pf_source,
            CURRENT_TIMESTAMP() AS pf_loaded_date,
            TRUE AS pf_is_active,
            ROW_NUMBER() OVER (PARTITION BY $1 ORDER BY METADATA$FILE_ROW_NUMBER DESC) AS row_num
        FROM @NEVADA (FILE_FORMAT => csvformat, PATTERN => '.*Crprtn.*') AS t  LIMIT 100
    ) t
        WHERE t.row_num = 1
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        entity_email = src.entity_email,
        corporation_name = src.corporation_name,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        naics = src.naics,
        naics_subcode = src.naics_subcode,
        annual_report_due_date = src.annual_report_due_date,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id, entity_email, corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, naics, naics_subcode, annual_report_due_date, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.entity_email, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.naics, src.naics_subcode, src.annual_report_due_date, src.pf_source, src.pf_loaded_date, src.pf_is_active);

```


![](../../../../img/Pasted%20image%2020240528125050.png)

Fixed query
```sql
MERGE INTO CORPORATION AS corp
USING (       
      
    SELECT
        *
    FROM (
        SELECT
            UUID_STRING() AS pf_id,
            CONCAT('NV', '_', t.$1) AS pf_state_corpid,
            'NV' AS pf_state,
            t.$1 AS corporation_id,
            t.$7 AS corporation_name, 
            t.$15 AS entity_address_1,
            t.$16 AS entity_address_2,
            t.$17 AS entity_city,
            t.$18 AS entity_state,
            t.$19 AS entity_zip,
            t.$20 AS entity_country,
            t.$5 AS status,
            TRY_TO_DATE(t.$21) AS creation_date, 
            TRY_TO_DATE(t.$25) AS end_date, 
            METADATA$FILENAME AS pf_source,
            CURRENT_TIMESTAMP() AS pf_loaded_date,
            TRUE AS pf_is_active,
            ROW_NUMBER() OVER (PARTITION BY $1 ORDER BY METADATA$FILE_ROW_NUMBER DESC) AS row_num
        FROM @NEVADA (FILE_FORMAT => csvformat, PATTERN => '.*Crprtn.*') AS t  
    ) t
        WHERE t.row_num = 1
) AS src
ON corp.pf_state_corpid = src.pf_state_corpid
WHEN MATCHED THEN
    UPDATE SET
        corporation_name = src.corporation_name,
        end_date = src.end_date,
        entity_address_1 = src.entity_address_1,
        entity_address_2 = src.entity_address_2,
        entity_city = src.entity_city,
        entity_state = src.entity_state,
        entity_zip = src.entity_zip,
        entity_country = src.entity_country,
        status = src.status,
        pf_source = src.pf_source,
        pf_loaded_date = src.pf_loaded_date,
        pf_is_active = src.pf_is_active
WHEN NOT MATCHED THEN
    INSERT (pf_id, pf_state_corpid, pf_state, corporation_id,  corporation_name, creation_date, end_date, entity_address_1, entity_address_2, entity_city, entity_state, entity_zip, entity_country, status, pf_source, pf_loaded_date, pf_is_active)
    VALUES (src.pf_id, src.pf_state_corpid, src.pf_state, src.corporation_id, src.corporation_name, src.creation_date, src.end_date, src.entity_address_1, src.entity_address_2, src.entity_city, src.entity_state, src.entity_zip, src.entity_country, src.status, src.pf_source, src.pf_loaded_date, src.pf_is_active);


```

- [ ] Account


### Florida


![](../../../../img/Pasted%20image%2020240528133027.png)

![](../../../../img/Pasted%20image%2020240528133040.png)
> Florida


Whats the raw copy file code?


File format, can it be loaded as ZIP?

### Compressed Files

`COMPRESSION = AUTO | GZIP | BZ2 | BROTLI | ZSTD | DEFLATE | RAW_DEFLATE | NONE`

Use

Data loading, data unloading, and external tables

Definition

- When loading data, specifies the current compression algorithm for the data file. Snowflake uses this option to detect how an already-compressed data file was compressed so that the compressed data in the file can be extracted for loading.
    
- When unloading data, compresses the data file using the specified compression algorithm.

![](../../../../img/Pasted%20image%2020240528133927.png)

- It looks like it is able to 

COMPRESSION = AUTO | GZIP | BZ2 | BROTLI | ZSTD | DEFLATE | RAW_DEFLATE | NONE

GZIP produces zipped files with the **.** **gz**


I think I might be misunderstanding how compression works here:


```
COPY INTO '@stage/my_output_file.zip'
FROM my_table
FILE_FORMAT = (TYPE = CSV COMPRESSION = ZIP);

```

> It seems that this is the correct way to show things.  So lets load as csv. and test

Get the copy

```
aws s3 cp cordata.zip s3://pfcorpdata/source/FL/20240528_135300/cordata.zip
```


This looks tab separated

![](../../../../img/Pasted%20image%2020240528144938.png)


It turns out it isn't. Is something called Text Width Format

https://community.snowflake.com/s/article/Ingesting-Fixed-Width-Text-Files-with-Snowflake

![](../../../../img/Pasted%20image%2020240528151837.png)


![](../../../../img/Pasted%20image%2020240528151925.png)

It should be the start and the end.

![](../../../../img/Pasted%20image%2020240528162541.png)


![](../../../../img/Pasted%20image%2020240528162550.png)


This is with fofcier title shortened moved to left 1

![](../../../../img/Pasted%20image%2020240528162911.png)



![](../../../../img/Pasted%20image%2020240528171605.png)

TRY_TO_DATE -> This is not right:

![](../../../../img/Pasted%20image%2020240528171946.png)

https://docs.snowflake.com/en/sql-reference/parameters#label-date-input-format

![](../../../../img/Pasted%20image%2020240528172304.png)

Here we have as follows:

![](../../../../img/Pasted%20image%2020240528172326.png)


That looks better


    TRY_TO_DATE(SUBSTR($1, 511, 8), 'MMDDYYYY') as report_date_1,

![](../../../../img/Pasted%20image%2020240528172437.png)

Entitiy mialing city?

entity_mailing_city


What do you mean end date is missing here?


![](../../../../img/Pasted%20image%2020240528174600.png)

Look at that `Trim` difference:


![](../../../../img/Pasted%20image%2020240528181258.png)

And without `Trim`:

![](../../../../img/Pasted%20image%2020240528181312.png)



It must be the report year

![](../../../../img/Pasted%20image%2020240528182447.png)

![](../../../../img/Pasted%20image%2020240528182502.png)

Where did that come from lol

![](../../../../img/Pasted%20image%2020240528182807.png)

Convert this into a boolean:

![](../../../../img/Pasted%20image%2020240528183828.png)

This should be clearly a Boolean indicating if there is more than 6 officers or not. 

Awesome, no need to specify things:

![](../../../../img/Pasted%20image%2020240528184050.png)

https://docs.snowflake.com/en/sql-reference/data-types-logical

Can you do it from extracting things?


What does raw defalte meant?

-- If TYPE = AVRO
     COMPRESSION = AUTO | GZIP | BROTLI | ZSTD | DEFLATE | RAW_DEFLATE | NONE
https://community.snowflake.com/s/article/FAQ

to my suprise as for 2022 this cannot be done
![](../../../../img/Pasted%20image%2020240528184859.png)



![](../../../../img/Pasted%20image%2020240529100622.png)
> Here we see that the emails between quarters are the same, my hypothesis was they should be depending on if they are still available. Will emails ever be replaced? SInce there are no orders, will there be a priority? or change?




![](../../../../img/Pasted%20image%2020240529103130.png)

Does this number make sense:
![](../../../../img/Pasted%20image%2020240529103349.png)
> Insertions UPDATE Emails


Merge from business body:

![](../../../../img/Pasted%20image%2020240529103435.png)

```
11269799

1546457
7365802
```


If you add them up it should be added to around 900 0000

![](../../../../img/Pasted%20image%2020240529112348.png)

> Why is it showing an empty distribution?


![](../../../../img/Pasted%20image%2020240529112642.png)
> Here the distribution

Resident Agent:
![](../../../../img/Pasted%20image%2020240529114250.png)


Nevermind it actually has RAID so it will find instead using raid:



CRPRT Officer has the 

![](../../../../img/Pasted%20image%2020240529114303.png)
![](../../../../img/Pasted%20image%2020240529114509.png)



Doesn't look like it supports 

![](../../../../img/Pasted%20image%2020240529153700.png)




